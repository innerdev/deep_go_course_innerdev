package main

import "fmt"

func main() {

	fmt.Printf("%08b\n", uint32((1<<1)-1))
	fmt.Printf("%08b\n", uint32(1))
	// Пусть мы хотим хранить в переменной set сразу несколько разных чисел и булевых флагов.

	// Сейчас число равно нулю, соответственно, все биты выставлены в ноль: 00000000000000000000000000000000
	var set uint32
	fmt.Printf("%032b\n", set)

	// Чтобы записать в начало числа (в наименее значимые разряды - они справа),
	// не нужно сдвигать вообще ничего, просто пишем в число (разумеется, записать нужно именно то, что будет идти в младших десяти битах)
	// Операция "|" работает потому, что все биты выставлены в ноль,
	// следовательно "или" вернет все биты, которые выставлены в uint32(1000) << 0 как единицы.
	set = set | (uint32(1000) << 0) // mana

	// Чтобы записать что-то еще, уже необходимо сдвинуть биты, чтобы писать туда, куда нам нужно, а не в начало.
	set = set | (uint32(1) << 10)    // для health используем 10 бит
	set = set | (uint32(1000) << 20) // и еще для чего-то используем 5 бит

	// Важно понимать, что размер того, что мы пишем не ограничен ничем (и сдвиг на него никак не влияет).
	// Если мы сдвинемся на 15 и запишем что-то огромное, то мы "испортим" все биты "за границей" (если мы хотели, чтобы число умещалось в определенное
	// количество бит, проверку на длину числа нужно сделать самому или просто не писать число больше, чем нужно)
	fmt.Printf("%032b\n", set)

	// Маска нужна для того, чтобы с помощью операции И (&) прочитать только те биты, которые нам на самом деле нужны.
	// Маска уже обязана быть той длины, сколько бит мы хотим прочитать. Если мы хотим прочитать 10 бит то маска должна выглядеть как
	// 00000000000000000000001111111111
	// и чтобы прочитать, нам понадобится подвинуть биты того байта, из которого мы читаем, на нужное количество, чтобы сравнить с маской.
	shift := 10
	mask := uint32((1 << shift) - 1) // вычитание единицы нужно, чтобы превратить 00010000 в 00001111, при этом единиц будет столько же, сколько число сдвига
	fmt.Printf("Mask: %032b\n", mask)

	// Другими словами - длина маски - это сколько бит мы хотим прочитать. А чтобы  их реально прочитать (сравнить исходник с маской),
	// нужно побитово "подвинуть" исходник прямо под маску, а затем выполнить "И".

	// Например, исходный сет:
	// 00000000000000000000000000000000
	// Он же после добавления чисел в разные участки:
	// 00111110100000000000011111101000 (1111101000 - это 1000, 0000000000001 - это 1; тут записано "1000 1 1000")
	// Маска:
	// 00000000000000000000001111111111

	// Поэтому чтобы прочитать единрицу из середины, необходимо сдвинуть сет вправо на 10 бит и сделать "И" с маской и кастануть в int.

	fmt.Printf("%032b\n", (set>>shift)&mask)

}
